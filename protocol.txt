DPI(Deep Packet Inspection)深度包检测技术是在传统IP数据包检测技术(OSI L2-L4之间包含的数据包元素的检测分析)之上增加了对应用层数据的应用协议识别，数据包内容检测与深度解码。

集线器是工作在物理层的设备，当他收到数据以后就把这个数据复制复制以后就把这个数据象所有的接口发送一次。所以集线器所有的接口是一个冲突域和广播域。
交换机就和集线器不一样了，交换机工作数据链路层的设备，他能够识别数据帧和MAC地址，他工作的方式就和集线器有很大的区别。交换机是依靠MAC地址表来转发数据。对于MAC地址表里没有的数据就广播。所以我们说交换机的每个接口都是一个冲突域，交换机的所有的接口都属于一个广播域。
路由器是工作在网络层的设备，路由器转发数据是依靠路由表来转发数据。对于广播流量路由器会处理但是不会转发数据。所以我们说路由器的每个接口都属于同一个冲突域和广播域。路由器可以用来隔离广播。
设备总结：
集线器（HUB）所有端口都在同一个广播域、冲突域内，所以HUB不能分割冲突域和广播域。
交换机（Switch）所有端口都在同一个广播域内，而每一个端口就是一个冲突域，所以交换机能分割冲突域，但分割不了广播域。虚拟局域网（Vlan）技术可以隔离广播域。
路由器（Router）的每个端口属于不同的广播域、冲突域。
冲突域：连接在同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合或以太网上竞争同一带宽的节点集合。这个域代表了冲突在其中发生并传播的区域，这个区域可以被认为是共享段。在OSI模型中，冲突域被看作是第一层的概念，连接同一冲突域的设备有Hub，Reperter或者其他进行简单复制信号的设备。也就是说，用Hub或者Repeater连接的所有节点可以被认为是在同一个冲突域内，它不会划分冲突域。而第二层设备（网桥，交换机）第三层设备（路由器）都可以划分冲突域的，当然也可以连接不同的冲突域。简单的说，可以将Repeater等看成是一根电缆，而将网桥等看成是一束电缆。
广播域：接收同样广播消息的节点的集合。如：在该集合中的任何一个节点传输一个广播帧，则所有其他能收到这个帧的节点都被认为是该广播帧的一部分。由于许多设备都极易产生广播，所以如果不维护，就会消耗大量的带宽，降低网络的效率。由于广播域被认为是OSI中的第二层概念，所以像Hub，交换机等第一，第二层设备连接的节点被认为都是在同一个广播域。而路由器，第三层交换机则可以划分广播域，即可以连接不同的广播域。

SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是"SOCKet Secure"的缩写。
当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。
这个协议最初由David Koblas开发，而后由NEC的Ying-Da Lee将其扩展到SOCKS4。最新协议是SOCKS5，与前一版本相比，增加支持UDP、验证，以及IPv6。
根据OSI模型，SOCKS是会话层的协议，位于表示层与传输层之间。
SOCKS协议不提供加密。

SOCKS5 vs HTTP proxy
Unlike HTTP proxies, which can only interpret and work with HTTP and HTTPS webpages, SOCKS5 proxies can work with any traffic.
HTTP proxies are high-level proxies usually designed for a specific protocol. While this means you get better connection speeds, they’re not nearly as flexible and secure as SOCKS proxies.
SOCKS proxies are low-level proxies that can handle any program or protocol and any traffic without limitations.

PAC (proxy auto-config)
代理自动配置文件是一个 JavaScript 脚本，其核心是一个 JavaScript 函数，用来决定网页浏览请求（HTTP、HTTPS，和 FTP）应当直连目标地址，还是被转发给一个网页代理服务器并通过代理连接。PAC 文件中的核心 JavaScript 函数通常是这样定义的：
    function FindProxyForURL(url, host) {
      // ...
    }
参数
    url:要访问的 URL。URL 中类似 https:// 这样的的路径和查询组件已被去除。在 Chrome 浏览器（版本 52 至 73）中, 你可以通过设置 PacHttpsUrlStrippingEnabled 为 false 来禁止这种行为，或者以 --unsafe-pac-url 命令行参数启动（自 Chrome 74 起，仅命令行参数有效，且在 Chrome 75 及之后的版本中无法禁用这种行为；至于 Chrome 81，路径剥离对 HTTP URL 不适用，但有意改变这一行为以适应 HTTPS）；在 Firefox 浏览器中，对应的选项是 network.proxy.autoconfig_url.include_path。
    host:从 URL 中提取得到的主机名。这只是为了方便；它与 :// 之后到第一个 : 或 / 之前的字符串相同。端口号不包括在此参数中，必要时可以自行从 URL 中提取。
返回值
    FindProxyForURL() 函数返回一个描述了代理设置的字符串
    字符串中可以包含如下任意数量的“代理配置块”（building blocks），用分号分隔：
    DIRECT                   直连，不经过任何代理
    PROXY host:port          HTTP 代理
    SOCKS host:port          SOCKS 代理
    如果那个字符串为空，则不使用任何代理。

VMess 协议是由 V2Ray 原创并使用于 V2Ray 的加密传输协议，如同 Shadowsocks 一样为了对抗墙的深度包检测而研发的。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。
V2Ray 使用 inbound(传入) 和 outbound(传出) 的结构，这样的结构非常清晰地体现了数据包的流动方向，同时也使得 V2Ray 功能强大复杂的同时而不混乱，清晰明了。形象地说，我们可以把 V2Ray 当作一个盒子，这个盒子有入口和出口(即 inbound 和 outbound)，我们将数据包通过某个入口放进这个盒子里，然后这个盒子以某种机制（这个机制其实就是路由，后面会讲到）决定这个数据包从哪个出口吐出来。以这样的角度理解的话，V2Ray 做客户端，则 inbound 接收来自浏览器数据，由 outbound 发出去(通常是发到 V2Ray 服务器)；V2Ray 做服务器，则 inbound 接收来自 V2Ray 客户端的数据，由 outbound 发出去(通常是如 Google 等想要访问的目标网站)。


WebSocket协议是html5的一种通信协议，该协议兼容我们常用的浏览器。它可以使客户端和服务端双向数据传输更加简单快捷，并且在TCP连接进行一次握手后，就可以持久性连接，同时允许服务端对客户端推送数据。外加传统模式的协议一般HTTP请求可能会包含较长的头部，但真正有效的可能只有小部分，从而就占用了很多资源和带宽。因此WebSocket协议不仅可以实时通讯，支持扩展；也可以压缩节省服务器资源和带宽。WS协议和WSS协议两个均是WebSocket协议的SCHEM，两者一个是非安全的，一个是安全的。
WebSocket协议的特点：建立在 TCP 协议之上，服务端实现容易；与 HTTP 协议有良好的兼容性，握手时不容易被屏蔽，可以通过各种 HTTP 代理服务器；数据轻量，实时通讯；可以发送文本和二进制数据。不限制同源，客户端可以与任意服务器端进行通讯。因此WebSocket协议的出现，为很多人解决了关于扩展以及兼容性协议的烦恼问题。
